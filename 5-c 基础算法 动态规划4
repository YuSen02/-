最长上升子序列
实现解释：

这里介绍的其实是优化后的方案，即只存储长度，而不是以dp[i][j]的形式存储ij之间的最长长度，不过也是很好理解的，所以就直接分享这一篇吧。

a[i]存储总序列的内容，dp[i]表示以i为结尾的最长子序列长度

那么首先由dp[i]开始一定是1（自己是一个序列）

后面的状态转移方程即：

dp[i] = max(dp[j])+1（j<i&&a[j]<a[i]）

解释：由于是上升序列，而且dp[i]是以i结尾的最长长度，因此长度增加时有两个条件：新的数字在旧数字的后面，新的数字大于旧的数字（新数字：dp[i]，旧数字：dp[j]），也是唯一的转移方程。

 

坑点：

注意最后获取最长序列时，不能直接dp[n]输出，因为可能是在序列中间有最长的上升子序列，也需要循环判断。
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin >> n;
    int a[n],dp[n];
    for(int i = 0;i<n;i++)
    {
        cin >> a[i];
        dp[i] = 1;//自身一定是一个长度的序列 
    }
    for(int i = 1;i<n;i++)
    {
        for(int j = 0;j<i;j++)
        {
            if(a[i] > a[j])//因为是上升，所以需要只有比前面的值大才可能形成最长上升子序列 
            {
                if(dp[i] < dp[j]+1) dp[i] = dp[j] + 1;//记录i处最长的上升序列长度
                //即前面的序列长度最大长度+1即是i处的最大长度
            }
        }
    }
    int max = dp[0];//不一定最后一个是最长的，因此需要获取最大值 
    for(int i = 1;i<n;i++)
    {
        if(max < dp[i]) max = dp[i];
    }
    cout << max << '\n';
    return 0;
}
